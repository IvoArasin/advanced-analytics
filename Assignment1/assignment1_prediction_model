import csv
import pandas as pd
import re
import numpy as np
import matplotlib.pyplot as plt
import math
import xgboost
import sklearn
from sklearn.neighbors import KNeighborsClassifier
import featuretools as ft
import missingno as msno
import ydata_profiling as yp
import datetime

train = pd.DataFrame(pd.read_csv('Assignment 1/data/assignment1_train.csv'))

# Train- and test-split right from the start
X = train.iloc[:, :-1]
y = train['target']
train_set, test_set, target_train, target_test = sklearn.model_selection.train_test_split(X, y, test_size=0.2)

######## EXPLORATORY DATA ANALYSIS ########
# make scatterplot of two variables, i.e. some feature and target (=price) to see if there's any correlation / pattern
#plt.scatter(train_set['property_max_guests'], target_train)
#plt.show()


######## PREPROCESSING PIPELINE ########
train_set.drop(['property_id', 'property_sqfeet'], axis=1, inplace=True)

# Impute ZIPCODE via KNN with Latitude and Longitude
zip_impute_data = pd.DataFrame({'lat': train_set['property_lat'], 'lon': train_set['property_lon'], 'zipcode': train_set['property_zipcode']})
zip_impute_data_nona = zip_impute_data[~zip_impute_data.isna().any(axis=1)] # ~ operator negates if it is NA, thus returns only complete rows without NA
zipcode_impute = KNeighborsClassifier(n_neighbors=2)
zipcode_impute.fit(zip_impute_data_nona.iloc[:,:-1], zip_impute_data_nona['zipcode'])
train_set['property_zipcode'] = train_set.apply(
    lambda x: zipcode_impute.predict(pd.DataFrame({'lat':[x['property_lat']],'lon':[x['property_lon']]})) if pd.isna(x['property_zipcode']) else x['property_zipcode'], axis=1)

# Create bins for property_type corresponding to target_variance
def prop_type_bins(t):
    if t in ['Apartment']:
        return 'apartment'
    if t in ['House']:
        return 'house'
    if t in ['Loft', 'Bed & Breakfast']:
        return 'loft_and_bdnbrfst'
    if t in ['Townhouse', 'Guesthouse', 'Condominium', 'Other']:
        return 'town_guest_condo_other'
    else:
        return 'other'

train_set['property_type'] = train_set.apply(lambda x: prop_type_bins(x['property_type']),axis=1)

# Change "host_since" to number of days since host has been active up until today
def datediff_in_days(d):
    try:
        return (datetime.datetime.utcnow() - datetime.datetime.strptime(str(d), '%Y-%m-%d')).days
    except (ValueError, TypeError):
        return 0

train_set['host_since_in_days'] = train_set.apply(lambda x: datediff_in_days(x['host_since']) , axis=1)
train_set.drop(['host_since'])


######## FUNCTIONS ########
def rmse(predictions, targets):
    rmse_val = pow(sum(pow(predictions - targets, 2)) / len(targets), 0.5)
    return(rmse_val)


######## PREDICTION MODEL ########


